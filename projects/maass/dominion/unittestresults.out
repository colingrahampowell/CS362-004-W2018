____________________________________________________
Testing kingdomCards()

	test position 0:
		Test successfully completed.
	test position 1:
		Test successfully completed.
	test position 2:
		Test successfully completed.
	test position 3:
		Test successfully completed.
	test position 4:
		Test successfully completed.
	test position 5:
		Test successfully completed.
	test position 6:
		Test successfully completed.
	test position 7:
		Test successfully completed.
	test position 8:
		Test successfully completed.
	test position 9:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing buyCard()

	curse cost:
		Test successfully completed.
	curse cost:
		Test successfully completed.
	estate cost:
		Test successfully completed.
	duchy cost:
		Test successfully completed.
	province cost:
		Test successfully completed.
	copper cost:
		Test successfully completed.
	silver cost:
		Test successfully completed.
	gold cost:
		Test successfully completed.
	adventurer cost:
		Test successfully completed.
	council_room cost:
		Test successfully completed.
	feast cost:
		Test successfully completed.
	gardens cost:
		Test successfully completed.
	mine cost:
		Test successfully completed.
	remodel cost:
		Test successfully completed.
	smithy cost:
		Test successfully completed.
	village cost:
		Test successfully completed.
	baron cost:
		Test successfully completed.
	great_hall cost:
		Test successfully completed.
	minion cost:
		Test successfully completed.
	steward cost:
		Test successfully completed.
	tribute cost:
		Test successfully completed.
	ambassador cost:
		Test successfully completed.
	cutpurse cost:
		Test successfully completed.
	embargo cost:
		Test successfully completed.
	outpost cost:
		Test successfully completed.
	salvager cost:
		Test successfully completed.
	sea_hag cost:
		Test successfully completed.
	treasure_map cost:
		Test successfully completed.
	other cost:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing supplyCount()

	Supply count card supply stack 1:
		Test successfully completed.
	Supply count card supply stack 2:
		Test successfully completed.
	Supply count card supply stack 3:
		Test successfully completed.
	Supply count card supply stack 4:
		Test successfully completed.
	Supply count card supply stack 5:
		Test successfully completed.
	Supply count card supply stack 6:
		Test successfully completed.
	Supply count card supply stack 7:
		Test successfully completed.
	Supply count card supply stack 8:
		Test successfully completed.
	Supply count card supply stack 9:
		Test successfully completed.
	Supply count card supply stack 10:
		Test successfully completed.
	Supply count card supply stack 11:
		Test successfully completed.
	Supply count card supply stack 12:
		Test successfully completed.
	Supply count card supply stack 13:
		Test successfully completed.
	Supply count card supply stack 14:
		Test successfully completed.
	Supply count card supply stack 15:
		Test successfully completed.
	Supply count card supply stack 16:
		Test successfully completed.
	Supply count card supply stack 17:
		Test successfully completed.
	Supply count card supply stack 18:
		Test successfully completed.
	Supply count card supply stack 19:
		Test successfully completed.
	Supply count card supply stack 20:
		Test successfully completed.
	Supply count card supply stack 21:
		Test successfully completed.
	Supply count card supply stack 22:
		Test successfully completed.
	Supply count card supply stack 23:
		Test successfully completed.
	Supply count card supply stack 24:
		Test successfully completed.
	Supply count card supply stack 25:
		Test successfully completed.
	Supply count card supply stack 26:
		Test successfully completed.
	Supply count card supply stack 27:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing smithy card

	play smithy successfully executes:
		Test successfully completed.
	correct number of cards in hand:
		Test failed.
	correct number of cards in deck:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing adventurer card

	play adventurer successfully executes:
		Test successfully completed.
	correct number of cards in hand:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing embargo card

	play embargo successfully executes:
		Test successfully completed.
	correct number of embargo tokens:
		Test successfully completed.
	correct number of cards in hand:
		Test successfully completed.
	correct number of coins:
		Test successfully completed.
____________________________________________________
____________________________________________________
Testing great hall card

	play great hall successfully executes:
		Test successfully completed.
	correct number of cards in hand:
		Test successfully completed.
	correct number of actions:
		Test successfully completed.
____________________________________________________
File 'unittest1.c'
Lines executed:100.00% of 33
Branches executed:100.00% of 10
Taken at least once:100.00% of 10
Calls executed:100.00% of 21
Creating 'unittest1.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:// testing isGameOver() function
        -:    8:
        -:    9:void asserttrue(int statement);
        -:   10:
        -:   11:
function main called 2 returned 100% blocks executed 100%
        2:   12:int main(int argc, char* argv[]) {
        2:   13:    char functionName[] = "isGameOver()";
        -:   14:    struct gameState state;
        2:   15:    int players = 2;
        2:   16:    int seed = 100;
        2:   17:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   18:		sea_hag, tribute, smithy};
        2:   19:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   20:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   21:	fflush(stdout);
call    0 returned 100%
        -:   22:    
        -:   23:    // init game
        2:   24:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   25:    
        -:   26:	// conditions that must be true, one or the other:
        -:   27:	//   province count must be zero
        -:   28:	//   3 supply piles are at zero
        -:   29:
        -:   30:    // test province count
        2:   31:    state.supplyCount[province] = 0; 
        2:   32:    printf("\tNo provinces left:\n");
call    0 returned 100%
        2:   33:    fflush(stdout);
call    0 returned 100%
        2:   34:    asserttrue(isGameOver(&state));
call    0 returned 100%
call    1 returned 100%
        -:   35:
        -:   36:    // reset changes
        2:   37:    state.supplyCount[province] = 1;
        -:   38:
        -:   39:    // test supply pile count
        -:   40:    // set 3 to 0, set rest to more
        -:   41:    // from enum CARD in dominion.h
        -:   42:    int card;
       56:   43:    for(card = curse; card <= treasure_map; card++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       54:   44:        state.supplyCount[card] = ((card < 3) ? 0 : 5);
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:   45:        //printf("Testing test: %d\n", state.supplyCount[card]);
        -:   46:    }
        2:   47:    printf("\tFirst 3 empty piles:\n");
call    0 returned 100%
        2:   48:    fflush(stdout);    
call    0 returned 100%
        2:   49:    asserttrue(isGameOver(&state));	
call    0 returned 100%
call    1 returned 100%
        -:   50:
       56:   51:    for(card = curse; card <= treasure_map; card++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       54:   52:        state.supplyCount[card] = ((card > treasure_map - 3) ? 0 : 5);
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        -:   53:        //printf("Testing test: %d\n", state.supplyCount[card]);
        -:   54:    }
        2:   55:    printf("\tLast 3 empty piles:\n");
call    0 returned 100%
        2:   56:    fflush(stdout);    
call    0 returned 100%
        2:   57:    asserttrue(isGameOver(&state));	
call    0 returned 100%
call    1 returned 100%
        -:   58:
        2:   59:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   60:	
        2:   61:    return 0;
        -:   62:}
        -:   63:
        -:   64:
        -:   65:
        -:   66:// adding own asserttrue as recommended
function asserttrue called 6 returned 100% blocks executed 100%
        6:   67:void asserttrue(int statement) {
        6:   68:    if (statement) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:   69:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
        4:   70:        fflush(stdout);
call    0 returned 100%
        -:   71:    } else {
        2:   72:        printf("\t\tTest failed.\n");
call    0 returned 100%
        2:   73:        fflush(stdout);
call    0 returned 100%
        -:   74:    }
        6:   75:}
File 'unittest2.c'
Lines executed:90.00% of 20
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
Calls executed:83.33% of 12
Creating 'unittest2.c.gcov'

        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:// testing kingdomCards() function
        -:    8:
        -:    9:void asserttrue(int statement);
        -:   10:
        -:   11:
function main called 2 returned 100% blocks executed 100%
        2:   12:int main(int argc, char* argv[]) {
        2:   13:    char functionName[] = "kingdomCards()";
        2:   14:	int control[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        2:   15:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   16:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   17:	fflush(stdout);
call    0 returned 100%
        -:   18:
        -:   19:    // What is the expected behavior??
        -:   20:    //  returns an int array that matches what was given
        2:   21:    int* test = kingdomCards(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
call    0 returned 100%
        -:   22:    // test all positions
        -:   23:    int i;
       22:   24:    for (i = 0; i < 10; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       20:   25:        printf("\ttest position %d:\n", i);
call    0 returned 100%
       20:   26:        fflush(stdout);
call    0 returned 100%
       20:   27:        asserttrue(control[i] == *(test + i));  
call    0 returned 100%
        -:   28:    }
        -:   29:    
        -:   30:
        2:   31:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   32:	
        2:   33:    return 0;
        -:   34:}
        -:   35:
        -:   36:
        -:   37:
        -:   38:// adding own asserttrue as recommended
function asserttrue called 20 returned 100% blocks executed 67%
       20:   39:void asserttrue(int statement) {
       20:   40:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       20:   41:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
       20:   42:        fflush(stdout);
call    0 returned 100%
        -:   43:    } else {
    #####:   44:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   45:        fflush(stdout);
call    0 never executed
        -:   46:    }
       20:   47:}
File 'unittest3.c'
Lines executed:97.22% of 72
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:97.89% of 95
Creating 'unittest3.c.gcov'

        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:// testing getCost() function
        -:    8:
        -:    9:void asserttrue(int statement);
        -:   10:
        -:   11:
function main called 3 returned 100% blocks executed 100%
        3:   12:int main(int argc, char* argv[]) {
        3:   13:    char functionName[] = "buyCard()";
        3:   14:	printf("____________________________________________________\n");
call    0 returned 100%
        3:   15:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        3:   16:	fflush(stdout);
call    0 returned 100%
        -:   17:    
        -:   18:    // for all cards in enum CARD, costs should be:
        3:   19:    printf("\tcurse cost:\n");
call    0 returned 100%
        3:   20: 	asserttrue(getCost(curse) == 0);
call    0 returned 100%
call    1 returned 100%
        3:   21:    printf("\tcurse cost:\n");
call    0 returned 100%
        3:   22:    asserttrue(getCost(curse) == 0);
call    0 returned 100%
call    1 returned 100%
        3:   23:    printf("\testate cost:\n");
call    0 returned 100%
        3:   24:    asserttrue(getCost(estate) == 2);
call    0 returned 100%
call    1 returned 100%
        3:   25:    printf("\tduchy cost:\n");
call    0 returned 100%
        3:   26:    asserttrue(getCost(duchy) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   27:    printf("\tprovince cost:\n");
call    0 returned 100%
        3:   28:    asserttrue(getCost(province) == 8);
call    0 returned 100%
call    1 returned 100%
        3:   29:    printf("\tcopper cost:\n");
call    0 returned 100%
        3:   30:    asserttrue(getCost(copper) == 0);
call    0 returned 100%
call    1 returned 100%
        3:   31:    printf("\tsilver cost:\n");
call    0 returned 100%
        3:   32:    asserttrue(getCost(silver) == 3);
call    0 returned 100%
call    1 returned 100%
        3:   33:    printf("\tgold cost:\n");
call    0 returned 100%
        3:   34:    asserttrue(getCost(gold) == 6);
call    0 returned 100%
call    1 returned 100%
        3:   35:    printf("\tadventurer cost:\n");
call    0 returned 100%
        3:   36:    asserttrue(getCost(adventurer) == 6);
call    0 returned 100%
call    1 returned 100%
        3:   37:    printf("\tcouncil_room cost:\n");
call    0 returned 100%
        3:   38:    asserttrue(getCost(council_room) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   39:    printf("\tfeast cost:\n");
call    0 returned 100%
        3:   40:    asserttrue(getCost(feast) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   41:    printf("\tgardens cost:\n");
call    0 returned 100%
        3:   42:    asserttrue(getCost(gardens) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   43:    printf("\tmine cost:\n");
call    0 returned 100%
        3:   44:    asserttrue(getCost(mine) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   45:    printf("\tremodel cost:\n");
call    0 returned 100%
        3:   46:    asserttrue(getCost(remodel) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   47:    printf("\tsmithy cost:\n");
call    0 returned 100%
        3:   48:    asserttrue(getCost(smithy) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   49:    printf("\tvillage cost:\n");
call    0 returned 100%
        3:   50:    asserttrue(getCost(village) == 3);
call    0 returned 100%
call    1 returned 100%
        3:   51:    printf("\tbaron cost:\n");
call    0 returned 100%
        3:   52:    asserttrue(getCost(baron) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   53:    printf("\tgreat_hall cost:\n");
call    0 returned 100%
        3:   54:    asserttrue(getCost(great_hall) == 3);
call    0 returned 100%
call    1 returned 100%
        3:   55:    printf("\tminion cost:\n");
call    0 returned 100%
        3:   56:    asserttrue(getCost(minion) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   57:    printf("\tsteward cost:\n");
call    0 returned 100%
        3:   58:    asserttrue(getCost(steward) == 3);
call    0 returned 100%
call    1 returned 100%
        3:   59:    printf("\ttribute cost:\n");
call    0 returned 100%
        3:   60:    asserttrue(getCost(tribute) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   61:    printf("\tambassador cost:\n");
call    0 returned 100%
        3:   62:    asserttrue(getCost(ambassador) == 3);
call    0 returned 100%
call    1 returned 100%
        3:   63:    printf("\tcutpurse cost:\n");
call    0 returned 100%
        3:   64:    asserttrue(getCost(cutpurse) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   65:    printf("\tembargo cost:\n");
call    0 returned 100%
        3:   66:    asserttrue(getCost(embargo) == 2);
call    0 returned 100%
call    1 returned 100%
        3:   67:    printf("\toutpost cost:\n");
call    0 returned 100%
        3:   68:    asserttrue(getCost(outpost) == 5);
call    0 returned 100%
call    1 returned 100%
        3:   69:    printf("\tsalvager cost:\n");
call    0 returned 100%
        3:   70:    asserttrue(getCost(salvager) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   71:    printf("\tsea_hag cost:\n");
call    0 returned 100%
        3:   72:    asserttrue(getCost(sea_hag) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   73:    printf("\ttreasure_map cost:\n");
call    0 returned 100%
        3:   74:    asserttrue(getCost(treasure_map) == 4);
call    0 returned 100%
call    1 returned 100%
        3:   75:    printf("\tother cost:\n");
call    0 returned 100%
        3:   76:    asserttrue(getCost(treasure_map + 1) == -1);
call    0 returned 100%
call    1 returned 100%
        3:   77:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   78:	
        3:   79:    return 0;
        -:   80:}
        -:   81:
        -:   82:
        -:   83:// adding own asserttrue as recommended
function asserttrue called 87 returned 100% blocks executed 67%
       87:   84:void asserttrue(int statement) {
       87:   85:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       87:   86:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
       87:   87:        fflush(stdout);
call    0 returned 100%
        -:   88:    } else {
    #####:   89:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   90:        fflush(stdout);
call    0 never executed
        -:   91:    }
       87:   92:}
File 'unittest4.c'
Lines executed:90.91% of 22
Branches executed:100.00% of 4
Taken at least once:75.00% of 4
Calls executed:83.33% of 12
Creating 'unittest4.c.gcov'

        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:
        -:    7:// testing supplyCount() function
        -:    8:
        -:    9:void asserttrue(int statement);
        -:   10:
        -:   11:
function main called 2 returned 100% blocks executed 100%
        2:   12:int main(int argc, char* argv[]) {
        2:   13:    char functionName[] = "supplyCount()";
        -:   14:    struct gameState state;
        2:   15:    int players = 2;
        2:   16:    int seed = 100;
        2:   17:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   18:		sea_hag, tribute, smithy};
        2:   19:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   20:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   21:	fflush(stdout);
call    0 returned 100%
        -:   22:    
        -:   23:    // init game
        2:   24:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   25:
        -:   26:    // What is the expected behavior??
        -:   27:    //  returned value should match 
        -:   28:    
        -:   29:    // run for all supplies
        -:   30:    int i;
       56:   31:    for(i = 0; i < (treasure_map + 1); i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
       54:   32:        state.supplyCount[i] = i + 2;
       54:   33:        printf("\tSupply count card supply stack %d:\n", i + 1);
call    0 returned 100%
       54:   34:        asserttrue(supplyCount(i, &state) == (i + 2));
call    0 returned 100%
call    1 returned 100%
        -:   35:    }
        -:   36:    
        2:   37:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   38:	
        2:   39:    return 0;
        -:   40:}
        -:   41:
        -:   42:
        -:   43:
        -:   44:// adding own asserttrue as recommended
function asserttrue called 54 returned 100% blocks executed 67%
       54:   45:void asserttrue(int statement) {
       54:   46:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       54:   47:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
       54:   48:        fflush(stdout);
call    0 returned 100%
        -:   49:    } else {
    #####:   50:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   51:        fflush(stdout);
call    0 never executed
        -:   52:    }
       54:   53:}
File 'cardtest1.c'
Lines executed:100.00% of 37
Branches executed:100.00% of 2
Taken at least once:100.00% of 2
Calls executed:100.00% of 21
Creating 'cardtest1.c.gcov'

        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "interface.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:// testing smithy card
        -:    9:
        -:   10:void asserttrue(int statement);
        -:   11:
        -:   12:
function main called 2 returned 100% blocks executed 100%
        2:   13:int main(int argc, char* argv[]) {
        2:   14:    char functionName[] = "smithy card";
        -:   15:    struct gameState state;
        2:   16:    int players = 2;
        2:   17:    int seed = 100;
        2:   18:    int choice1 = 0;    // not used for smithy
        2:   19:    int choice2 = 0;    // not used for smithy
        2:   20:    int choice3 = 0;    // not used for smithy
        2:   21:    int handPos = 0;
        2:   22:    int bonus = 0;      // not used for smithy
        2:   23:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   24:		sea_hag, tribute, smithy};
        2:   25:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   26:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   27:	fflush(stdout);
call    0 returned 100%
        -:   28:    
        -:   29:    // init game
        2:   30:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   31:
        -:   32:    // What is the expected behavior??
        -:   33:    //  +3 cards...from the deck
        -:   34:    //  check that hand has increased and deck has decreased  
        -:   35:    //  card is discarded at the end, so net +2
        2:   36:    int handCountBefore = numHandCards(&state);
call    0 returned 100%
        2:   37:    int deckCountBefore = state.deckCount[0];
        -:   38:    // int discardCountBefore = state.discardCount[0];
        2:   39:    printf("\tplay smithy successfully executes:\n");
call    0 returned 100%
        2:   40:    fflush(stdout); 
call    0 returned 100%
        2:   41:    int played =  (cardEffect(smithy, choice1, choice2, choice3, &state, handPos, &bonus) == 0);
call    0 returned 100%
        2:   42:    asserttrue(played);
call    0 returned 100%
        2:   43:    int handCountAfter = numHandCards(&state);
call    0 returned 100%
        2:   44:    int deckCountAfter = state.deckCount[0];
        -:   45:    // int discardCountAfter = state.discardCount[0];
        -:   46:    
        2:   47:    printf("\tcorrect number of cards in hand:\n");
call    0 returned 100%
        2:   48:    fflush(stdout);     
call    0 returned 100%
        -:   49:    // 2 because + 3 and we played 1.
        2:   50:    asserttrue((handCountAfter - handCountBefore) == 2);
call    0 returned 100%
        -:   51:
        2:   52:    printf("\tcorrect number of cards in deck:\n");
call    0 returned 100%
        2:   53:    fflush(stdout);
call    0 returned 100%
        -:   54:    // 4 because we drew 3, would have to add for discard if 
        -:   55:    // that was being set - may be a bug for future investigation
        2:   56:    asserttrue((deckCountBefore - deckCountAfter) == 4);
call    0 returned 100%
        -:   57:
        2:   58:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   59:	
        2:   60:    return 0;
        -:   61:}
        -:   62:
        -:   63:
        -:   64:
        -:   65:// adding own asserttrue as recommended
function asserttrue called 6 returned 100% blocks executed 100%
        6:   66:void asserttrue(int statement) {
        6:   67:    if (statement) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:   68:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
        4:   69:        fflush(stdout);
call    0 returned 100%
        -:   70:    } else {
        2:   71:        printf("\t\tTest failed.\n");
call    0 returned 100%
        2:   72:        fflush(stdout);
call    0 returned 100%
        -:   73:    }
        6:   74:}
File 'cardtest2.c'
Lines executed:93.75% of 32
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:88.89% of 18
Creating 'cardtest2.c.gcov'

        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "interface.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:// testing adventurer card
        -:    9:
        -:   10:void asserttrue(int statement);
        -:   11:
        -:   12:
function main called 2 returned 100% blocks executed 100%
        2:   13:int main(int argc, char* argv[]) {
        2:   14:    char functionName[] = "adventurer card";
        -:   15:    struct gameState state;
        2:   16:    int players = 2;
        2:   17:    int seed = 100;
        2:   18:    int choice1 = 0;    // not used for adventurer
        2:   19:    int choice2 = 0;    // not used for adventurer
        2:   20:    int choice3 = 0;    // not used for adventurer
        2:   21:    int handPos = 0;    // not used for adventurer
        2:   22:    int bonus = 0;      // not used for adventurer
        2:   23:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   24:		sea_hag, tribute, smithy};
        2:   25:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   26:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   27:	fflush(stdout);
call    0 returned 100%
        -:   28:    
        -:   29:    // init game
        2:   30:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   31:
        -:   32:    // What is the expected behavior??
        -:   33:    //  +2 treasure if they exist
        -:   34:
        2:   35:    int handCountBefore = numHandCards(&state);
call    0 returned 100%
        -:   36:
        2:   37:    printf("\tplay adventurer successfully executes:\n");
call    0 returned 100%
        2:   38:    fflush(stdout); 
call    0 returned 100%
        2:   39:    int played =  (cardEffect(adventurer, choice1, choice2, choice3, &state, handPos, &bonus) == 0);
call    0 returned 100%
        2:   40:    asserttrue(played);
call    0 returned 100%
        2:   41:    int handCountAfter = numHandCards(&state);
call    0 returned 100%
        -:   42:    
        2:   43:    printf("\tcorrect number of cards in hand:\n");
call    0 returned 100%
        2:   44:    fflush(stdout);     
call    0 returned 100%
        2:   45:    asserttrue((handCountAfter - handCountBefore) == 2);
call    0 returned 100%
        -:   46:
        2:   47:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   48:	
        2:   49:    return 0;
        -:   50:}
        -:   51:
        -:   52:
        -:   53:
        -:   54:// adding own asserttrue as recommended
function asserttrue called 4 returned 100% blocks executed 67%
        4:   55:void asserttrue(int statement) {
        4:   56:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:   57:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
        4:   58:        fflush(stdout);
call    0 returned 100%
        -:   59:    } else {
    #####:   60:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   61:        fflush(stdout);
call    0 never executed
        -:   62:    }
        4:   63:}
File 'cardtest3.c'
Lines executed:95.24% of 42
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:91.67% of 24
Creating 'cardtest3.c.gcov'

        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "interface.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:// testing embargo card
        -:    9:
        -:   10:void asserttrue(int statement);
        -:   11:
        -:   12:
function main called 2 returned 100% blocks executed 100%
        2:   13:int main(int argc, char* argv[]) {
        2:   14:    char functionName[] = "embargo card";
        -:   15:    struct gameState state;
        2:   16:    int players = 2;
        2:   17:    int seed = 100;
        2:   18:    int choice1 = 0;    
        2:   19:    int choice2 = 0;    // not used for embargo
        2:   20:    int choice3 = 0;    // not used for embargo
        2:   21:    int handPos = 0;    
        2:   22:    int bonus = 0;      // not used for embargo
        2:   23:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   24:		sea_hag, tribute, smithy};
        2:   25:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   26:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   27:	fflush(stdout);
call    0 returned 100%
        -:   28:    
        -:   29:    // init game
        2:   30:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   31:
        -:   32:    // What is the expected behavior??
        -:   33:    //  +1 embargo token
        -:   34:    //  -1 in hand (from trashing card)
        -:   35:    //  +2 coins 
        -:   36:    
        2:   37:    int embargoCountBefore = state.embargoTokens[choice1];
        2:   38:    int handCountBefore = numHandCards(&state);
call    0 returned 100%
        2:   39:    int cointCountBefore = state.coins;
        -:   40:
        2:   41:    printf("\tplay embargo successfully executes:\n");
call    0 returned 100%
        2:   42:    fflush(stdout); 
call    0 returned 100%
        2:   43:    int played =  (cardEffect(embargo, choice1, choice2, choice3, &state, handPos, &bonus) == 0);
call    0 returned 100%
        2:   44:    asserttrue(played);
call    0 returned 100%
        2:   45:    int embargoCountAfter = state.embargoTokens[choice1];
        2:   46:    int handCountAfter = numHandCards(&state);
call    0 returned 100%
        2:   47:    int cointCountAfter = state.coins;
        -:   48: 
        2:   49:    printf("\tcorrect number of embargo tokens:\n");
call    0 returned 100%
        2:   50:    fflush(stdout);     
call    0 returned 100%
        2:   51:    asserttrue((embargoCountAfter - embargoCountBefore) == 1);
call    0 returned 100%
        -:   52:    
        2:   53:    printf("\tcorrect number of cards in hand:\n");
call    0 returned 100%
        2:   54:    fflush(stdout);     
call    0 returned 100%
        2:   55:    asserttrue((handCountBefore - handCountAfter) == 1);
call    0 returned 100%
        -:   56:
        2:   57:    printf("\tcorrect number of coins:\n");
call    0 returned 100%
        2:   58:    fflush(stdout);     
call    0 returned 100%
        2:   59:    asserttrue((cointCountAfter - cointCountBefore) == 2);
call    0 returned 100%
        -:   60:
        2:   61:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   62:	
        2:   63:    return 0;
        -:   64:}
        -:   65:
        -:   66:
        -:   67:
        -:   68:// adding own asserttrue as recommended
function asserttrue called 8 returned 100% blocks executed 67%
        8:   69:void asserttrue(int statement) {
        8:   70:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        8:   71:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
        8:   72:        fflush(stdout);
call    0 returned 100%
        -:   73:    } else {
    #####:   74:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   75:        fflush(stdout);
call    0 never executed
        -:   76:    }
        8:   77:}
File 'cardtest4.c'
Lines executed:94.59% of 37
Branches executed:100.00% of 2
Taken at least once:50.00% of 2
Calls executed:90.48% of 21
Creating 'cardtest4.c.gcov'

        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "interface.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:
        -:    8:// testing great hall card
        -:    9:
        -:   10:void asserttrue(int statement);
        -:   11:
        -:   12:
function main called 2 returned 100% blocks executed 100%
        2:   13:int main(int argc, char* argv[]) {
        2:   14:    char functionName[] = "great hall card";
        -:   15:    struct gameState state;
        2:   16:    int players = 2;
        2:   17:    int seed = 100;
        2:   18:    int choice1 = 0;    // not used for great hall
        2:   19:    int choice2 = 0;    // not used for great hall
        2:   20:    int choice3 = 0;    // not used for great hall
        2:   21:    int handPos = 0;    
        2:   22:    int bonus = 0;      // not used for great hall
        2:   23:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   24:		sea_hag, tribute, smithy};
        2:   25:	printf("____________________________________________________\n");
call    0 returned 100%
        2:   26:	printf("Testing %s\n\n", functionName);
call    0 returned 100%
        2:   27:	fflush(stdout);
call    0 returned 100%
        -:   28:    
        -:   29:    // init game
        2:   30:    initializeGame(players, k, seed, &state);
call    0 returned 100%
        -:   31:
        -:   32:    // What is the expected behavior??
        -:   33:    //  +1 card
        -:   34:    //  +1 action
        -:   35:    
        2:   36:    int handCountBefore = numHandCards(&state);
call    0 returned 100%
        2:   37:    int actionCountBefore = state.numActions;
        -:   38:
        2:   39:    printf("\tplay great hall successfully executes:\n");
call    0 returned 100%
        2:   40:    fflush(stdout); 
call    0 returned 100%
        2:   41:    int played =  (cardEffect(great_hall, choice1, choice2, choice3, &state, handPos, &bonus) == 0);
call    0 returned 100%
        2:   42:    asserttrue(played);
call    0 returned 100%
        2:   43:    int handCountAfter = numHandCards(&state);
call    0 returned 100%
        2:   44:    int actionCountAfter = state.numActions;
        -:   45:    
        2:   46:    printf("\tcorrect number of cards in hand:\n");
call    0 returned 100%
        2:   47:    fflush(stdout);
call    0 returned 100%
        -:   48:    // +1 new card, -1 discard, net 0
        2:   49:    asserttrue((handCountBefore - handCountAfter) == 0);
call    0 returned 100%
        -:   50:
        2:   51:    printf("\tcorrect number of actions:\n");
call    0 returned 100%
        2:   52:    fflush(stdout);     
call    0 returned 100%
        2:   53:    asserttrue((actionCountAfter - actionCountBefore) == 1);
call    0 returned 100%
        -:   54:
        2:   55:	printf("____________________________________________________\n");
call    0 returned 100%
        -:   56:	
        2:   57:    return 0;
        -:   58:}
        -:   59:
        -:   60:
        -:   61:
        -:   62:// adding own asserttrue as recommended
function asserttrue called 6 returned 100% blocks executed 67%
        6:   63:void asserttrue(int statement) {
        6:   64:    if (statement) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:   65:        printf("\t\tTest successfully completed.\n");
call    0 returned 100%
        6:   66:        fflush(stdout);
call    0 returned 100%
        -:   67:    } else {
    #####:   68:        printf("\t\tTest failed.\n");
call    0 never executed
    #####:   69:        fflush(stdout);
call    0 never executed
        -:   70:    }
        6:   71:}
File 'dominion.c'
Lines executed:33.98% of 565
Branches executed:33.81% of 417
Taken at least once:25.18% of 417
Calls executed:19.35% of 93
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:21
        -:    0:Programs:12
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 390 returned 100% blocks executed 83%
      390:    8:int compare(const void* a, const void* b) {
      390:    9:	if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:		return 1;
      390:   11:	if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
      104:   12:		return -1;
      286:   13:	return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:	return g;
        -:   19:}
        -:   20:
function kingdomCards called 6 returned 100% blocks executed 100%
        6:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:                  int k8, int k9, int k10) {
        6:   23:	int* k = malloc(10 * sizeof(int));
        6:   24:	k[0] = k1;
        6:   25:	k[1] = k2;
        6:   26:	k[2] = k3;
        6:   27:	k[3] = k4;
        6:   28:	k[4] = k5;
        6:   29:	k[5] = k6;
        6:   30:	k[6] = k7;
        6:   31:	k[7] = k8;
        6:   32:	k[8] = k9;
        6:   33:	k[9] = k10;
        6:   34:	return k;
        -:   35:}
        -:   36:
function initializeGame called 13 returned 100% blocks executed 88%
       13:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:                   struct gameState* state) {
        -:   39:	int i;
        -:   40:	int j;
        -:   41:	int it;
        -:   42:	//set up random number generator
       13:   43:	SelectStream(1);
call    0 returned 100%
       13:   44:	PutSeed((long)randomSeed);
call    0 returned 100%
        -:   45:
        -:   46:	//check number of players
       13:   47:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   48:		return -1;
        -:   49:
        -:   50:	//set number of players
       13:   51:	state->numPlayers = numPlayers;
        -:   52:
        -:   53:	//check selected kingdom cards are different
      143:   54:	for (i = 0; i < 10; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1430:   55:		for (j = 0; j < 10; j++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1300:   56:			if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   57:				return -1;
        -:   58:		}
        -:   59:	}
        -:   60:
        -:   61:
        -:   62:	//initialize supply
        -:   63:	///////////////////////////////
        -:   64:
        -:   65:	//set number of Curse cards
       13:   66:	if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:   67:		state->supplyCount[curse] = 10;
    #####:   68:	else if (numPlayers == 3)
branch  0 never executed
branch  1 never executed
    #####:   69:		state->supplyCount[curse] = 20;
        -:   70:	else
    #####:   71:		state->supplyCount[curse] = 30;
        -:   72:
        -:   73:
        -:   74:	//set number of Victory cards
       13:   75:	if (numPlayers == 2) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:   76:		state->supplyCount[estate] = 8;
       13:   77:		state->supplyCount[duchy] = 8;
       13:   78:		state->supplyCount[province] = 8;
        -:   79:	} else {
    #####:   80:		state->supplyCount[estate] = 12;
    #####:   81:		state->supplyCount[duchy] = 12;
    #####:   82:		state->supplyCount[province] = 12;
        -:   83:	}
        -:   84:
        -:   85:	//set number of Treasure cards
       13:   86:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       13:   87:	state->supplyCount[silver] = 40;
       13:   88:	state->supplyCount[gold] = 30;
        -:   89:
        -:   90:	//set number of Kingdom cards
      273:   91:	for (i = adventurer; i <= treasure_map; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:   92:		//loop all cards
     2145:   93:		for (j = 0; j < 10; j++) {
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:   94:			//loop chosen cards
     2015:   95:			if (kingdomCards[j] == i) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:   96:				//check if card is a 'Victory' Kingdom card
      130:   97:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
       26:   98:					if (numPlayers == 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:   99:						state->supplyCount[i] = 8;
        -:  100:					else 
    #####:  101:						state->supplyCount[i] = 12; 
        -:  102:				} else {
      117:  103:					state->supplyCount[i] = 10;
        -:  104:				}
      130:  105:				break;
        -:  106:			} else {
        -:  107:				//card is not in the set choosen for the game
     1885:  108:				state->supplyCount[i] = -1;
        -:  109:			}
        -:  110:		}
        -:  111:	}
        -:  112:
        -:  113:	////////////////////////
        -:  114:	//supply intilization complete
        -:  115:
        -:  116:	//set player decks
       39:  117:	for (i = 0; i < numPlayers; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       26:  118:		state->deckCount[i] = 0;
      104:  119:		for (j = 0; j < 3; j++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       78:  120:			state->deck[i][j] = estate;
       78:  121:			state->deckCount[i]++;
        -:  122:		}
      208:  123:		for (j = 3; j < 10; j++) {
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
      182:  124:			state->deck[i][j] = copper;
      182:  125:			state->deckCount[i]++;
        -:  126:		}
        -:  127:	}
        -:  128:
        -:  129:	//shuffle player decks
       39:  130:	for (i = 0; i < numPlayers; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       26:  131:		if (shuffle(i, state) < 0)
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  132:			return -1;
        -:  133:	}
        -:  134:
        -:  135:	//draw player hands
       39:  136:	for (i = 0; i < numPlayers; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  137:		//initialize hand size to zero
       26:  138:		state->handCount[i] = 0;
       26:  139:		state->discardCount[i] = 0;
        -:  140:		//draw 5 cards
        -:  141:		// for (j = 0; j < 5; j++)
        -:  142:		//	{
        -:  143:		//	  drawCard(i, state);
        -:  144:		//	}
        -:  145:	}
        -:  146:
        -:  147:	//set embargo tokens to 0 for all supply piles
      364:  148:	for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      351:  149:		state->embargoTokens[i] = 0;
        -:  150:
        -:  151:	//initialize first player's turn
       13:  152:	state->outpostPlayed = 0;
       13:  153:	state->phase = 0;
       13:  154:	state->numActions = 1;
       13:  155:	state->numBuys = 1;
       13:  156:	state->playedCardCount = 0;
       13:  157:	state->whoseTurn = 0;
       13:  158:	state->handCount[state->whoseTurn] = 0;
        -:  159:	//int it; move to top
        -:  160:
        -:  161:	//Moved draw cards to here, only drawing at the start of a turn
       78:  162:	for (it = 0; it < 5; it++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       65:  163:		drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  164:
       13:  165:	updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  166:
       13:  167:	return 0;
        -:  168:}
        -:  169:
function shuffle called 26 returned 100% blocks executed 94%
       26:  170:int shuffle(int player, struct gameState* state) {
        -:  171:	int newDeck[MAX_DECK];
       26:  172:	int newDeckPos = 0;
        -:  173:	int card;
        -:  174:	int i;
        -:  175:
       26:  176:	if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  177:		return -1;
       26:  178:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
call    0 returned 100%
        -:  179:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  180:
      312:  181:	while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      260:  182:		card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
      260:  183:		newDeck[newDeckPos] = state->deck[player][card];
      260:  184:		newDeckPos++;
        -:  185:		
      936:  186:		for (i = card; i < state->deckCount[player] - 1; i++)
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
      676:  187:			state->deck[player][i] = state->deck[player][i + 1];
        -:  188:		
      260:  189:		state->deckCount[player]--;
        -:  190:	}
        -:  191:	
      286:  192:	for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
      260:  193:		state->deck[player][i] = newDeck[i];
      260:  194:		state->deckCount[player]++;
        -:  195:	}
        -:  196:
       26:  197:	return 0;
        -:  198:}
        -:  199:
function playCard called 0 returned 0% blocks executed 0%
    #####:  200:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState* state) {
        -:  201:	int card;
    #####:  202:	int coin_bonus = 0; //tracks coins gain from actions
        -:  203:
        -:  204:	//check if it is the right phase
    #####:  205:	if (state->phase != 0)
branch  0 never executed
branch  1 never executed
    #####:  206:		return -1;
        -:  207:
        -:  208:	//check if player has enough actions
    #####:  209:	if (state->numActions < 1)
branch  0 never executed
branch  1 never executed
    #####:  210:		return -1;
        -:  211:
        -:  212:	//get card played
    #####:  213:	card = handCard(handPos, state);
call    0 never executed
        -:  214:
        -:  215:	//check if selected card is an action
    #####:  216:	if (card < adventurer || card > treasure_map)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  217:		return -1;
        -:  218:
        -:  219:	//play card
    #####:  220:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  221:		return -1;
        -:  222:
        -:  223:	//reduce number of actions
    #####:  224:	state->numActions--;
        -:  225:
        -:  226:	//update coins (Treasure cards may be added with card draws)
    #####:  227:	updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  228:
    #####:  229:	return 0;
        -:  230:}
        -:  231:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  232:int buyCard(int supplyPos, struct gameState* state) {
        -:  233:	int who;
        -:  234:	if (DEBUG)
        -:  235:		printf("Entering buyCard...\n");
        -:  236:
        -:  237:	// I don't know what to do about the phase thing.
        -:  238:
    #####:  239:	who = state->whoseTurn;
        -:  240:
    #####:  241:	if (state->numBuys < 1) {
branch  0 never executed
branch  1 never executed
        -:  242:		if (DEBUG)
        -:  243:			printf("You do not have any buys left\n");
    #####:  244:		return -1;
    #####:  245:	} else if (supplyCount(supplyPos, state) < 1) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  246:		if (DEBUG)
        -:  247:			printf("There are not any of that type of card left\n");
    #####:  248:		return -1;
    #####:  249:	} else if (state->coins < getCost(supplyPos)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  250:		if (DEBUG)
        -:  251:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  252:		return -1;
        -:  253:	} else {
    #####:  254:		state->phase = 1;
        -:  255:		//state->supplyCount[supplyPos]--;
    #####:  256:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  257:
    #####:  258:		state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  259:		state->numBuys--;
        -:  260:		if (DEBUG)
        -:  261:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  262:	}
        -:  263:
        -:  264:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  265:	//state->discardCount[who]++;
        -:  266:
    #####:  267:	return 0;
        -:  268:}
        -:  269:
function numHandCards called 16 returned 100% blocks executed 100%
       16:  270:int numHandCards(struct gameState* state) {
       16:  271:	return state->handCount[whoseTurn(state)];
call    0 returned 100%
        -:  272:}
        -:  273:
function handCard called 0 returned 0% blocks executed 0%
    #####:  274:int handCard(int handPos, struct gameState* state) {
    #####:  275:	int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  276:	return state->hand[currentPlayer][handPos];
        -:  277:}
        -:  278:
function supplyCount called 54 returned 100% blocks executed 100%
       54:  279:int supplyCount(int card, struct gameState* state) {
       54:  280:	return state->supplyCount[card];
        -:  281:}
        -:  282:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  283:int fullDeckCount(int player, int card, struct gameState* state) {
        -:  284:	int i;
    #####:  285:	int count = 0;
        -:  286:
    #####:  287:	for (i = 0; i < state->deckCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  288:		if (state->deck[player][i] == card) 
branch  0 never executed
branch  1 never executed
    #####:  289:			count++;
        -:  290:	}
        -:  291:
    #####:  292:	for (i = 0; i < state->handCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  293:		if (state->hand[player][i] == card) 
branch  0 never executed
branch  1 never executed
    #####:  294:			count++;
        -:  295:	}
        -:  296:
    #####:  297:	for (i = 0; i < state->discardCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  298:		if (state->discard[player][i] == card) 
branch  0 never executed
branch  1 never executed
    #####:  299:			count++;
        -:  300:	}
        -:  301:
    #####:  302:	return count;
        -:  303:}
        -:  304:
function whoseTurn called 24 returned 100% blocks executed 100%
       24:  305:int whoseTurn(struct gameState* state) {
       24:  306:	return state->whoseTurn;
        -:  307:}
        -:  308:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  309:int endTurn(struct gameState* state) {
        -:  310:	int k;
        -:  311:	int i;
    #####:  312:	int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  313:
        -:  314:	//Discard hand
    #####:  315:	for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
        -:  316:		//Discard
    #####:  317:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];
        -:  318:		//Set card to -1
    #####:  319:		state->hand[currentPlayer][i] = -1;
        -:  320:	}
        -:  321:	//Reset hand count
    #####:  322:	state->handCount[currentPlayer] = 0;
        -:  323:
        -:  324:	//Code for determining the player
    #####:  325:	if (currentPlayer < (state->numPlayers - 1)) {
branch  0 never executed
branch  1 never executed
        -:  326:		//Still safe to increment
    #####:  327:		state->whoseTurn = currentPlayer + 1;
        -:  328:	} else {
        -:  329:		//Max player has been reached, loop back around to player 1
    #####:  330:		state->whoseTurn = 0;
        -:  331:	}
        -:  332:
    #####:  333:	state->outpostPlayed = 0;
    #####:  334:	state->phase = 0;
    #####:  335:	state->numActions = 1;
    #####:  336:	state->coins = 0;
    #####:  337:	state->numBuys = 1;
    #####:  338:	state->playedCardCount = 0;
    #####:  339:	state->handCount[state->whoseTurn] = 0;
        -:  340:
        -:  341:	//int k; move to top
        -:  342:	//Next player draws hand
    #####:  343:	for (k = 0; k < 5; k++) {
branch  0 never executed
branch  1 never executed
        -:  344:		//Draw a card
    #####:  345:		drawCard(state->whoseTurn, state);
call    0 never executed
        -:  346:	}
        -:  347:
        -:  348:	//Update money
    #####:  349:	updateCoins(state->whoseTurn, state, 0);
call    0 never executed
        -:  350:
    #####:  351:	return 0;
        -:  352:}
        -:  353:
function isGameOver called 6 returned 100% blocks executed 100%
        6:  354:int isGameOver(struct gameState* state) {
        -:  355:	int i;
        -:  356:	int j;
        -:  357:
        -:  358:	//if stack of Province cards is empty, the game ends
        6:  359:	if (state->supplyCount[province] == 0) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        2:  360:		return 1;
        -:  361:	}
        -:  362:
        -:  363:	//if three supply pile are at 0, the game ends
        4:  364:	j = 0;
      104:  365:	for (i = 0; i < 25; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      100:  366:		if (state->supplyCount[i] == 0) {
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        8:  367:			j++;
        -:  368:		}
        -:  369:	}
        4:  370:	if (j >= 3) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  371:		return 1;
        -:  372:	}
        -:  373:
        2:  374:	return 0;
        -:  375:}
        -:  376:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  377:int scoreFor(int player, struct gameState* state) {
        -:  378:	int i;
    #####:  379:	int score = 0;
        -:  380:	//score from hand
    #####:  381:	for (i = 0; i < state->handCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  382:		if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  383:		if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  384:		if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  385:		if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  386:		if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  387:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  388:	}
        -:  389:
        -:  390:	//score from discard
    #####:  391:	for (i = 0; i < state->discardCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  392:		if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  393:		if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  394:		if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  395:		if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  396:		if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  397:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  398:	}
        -:  399:
        -:  400:	//score from deck
    #####:  401:	for (i = 0; i < state->discardCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  402:		if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  403:		if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  404:		if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  405:		if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  406:		if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  407:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  408:	}
        -:  409:
    #####:  410:	return score;
        -:  411:}
        -:  412:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  413:int getWinners(int players[MAX_PLAYERS], struct gameState* state)
        -:  414:{
        -:  415:	int i;
        -:  416:	int j;
        -:  417:	int highScore;
        -:  418:	int currentPlayer;
        -:  419:
        -:  420:	//get score for each player
    #####:  421:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  422:	{
        -:  423:		//set unused player scores to -9999
    #####:  424:		if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  425:		{
    #####:  426:			players[i] = -9999;
        -:  427:		}
        -:  428:		else
        -:  429:		{
    #####:  430:			players[i] = scoreFor(i, state);
call    0 never executed
        -:  431:		}
        -:  432:	}
        -:  433:
        -:  434:	//find highest score
    #####:  435:	j = 0;
    #####:  436:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  437:	{
    #####:  438:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  439:		{
    #####:  440:			j = i;
        -:  441:		}
        -:  442:	}
    #####:  443:	highScore = players[j];
        -:  444:
        -:  445:	//add 1 to players who had less turns
    #####:  446:	currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  447:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  448:	{
    #####:  449:		if (players[i] == highScore && i > currentPlayer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  450:		{
    #####:  451:			players[i]++;
        -:  452:		}
        -:  453:	}
        -:  454:
        -:  455:	//find new highest score
    #####:  456:	j = 0;
    #####:  457:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  458:	{
    #####:  459:		if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  460:		{
    #####:  461:			j = i;
        -:  462:		}
        -:  463:	}
    #####:  464:	highScore = players[j];
        -:  465:
        -:  466:	//set winners in array to 1 and rest to 0
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:		if (players[i] == highScore)
branch  0 never executed
branch  1 never executed
        -:  470:		{
    #####:  471:			players[i] = 1;
        -:  472:		}
        -:  473:		else
        -:  474:		{
    #####:  475:			players[i] = 0;
        -:  476:		}
        -:  477:	}
        -:  478:
    #####:  479:	return 0;
        -:  480:}
        -:  481:
function drawCard called 79 returned 100% blocks executed 38%
       79:  482:int drawCard(int player, struct gameState* state) {
        -:  483:	int count;
        -:  484:	int deckCounter;
       79:  485:	if (state->deckCount[player] <= 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  486:		//Deck is empty
        -:  487:
        -:  488:		//Step 1 Shuffle the discard pile back into a deck
        -:  489:		int i;
        -:  490:		//Move discard to deck
    #####:  491:		for (i = 0; i < state->discardCount[player]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  492:			state->deck[player][i] = state->discard[player][i];
    #####:  493:			state->discard[player][i] = -1;
        -:  494:		}
        -:  495:
    #####:  496:		state->deckCount[player] = state->discardCount[player];
        -:  497:		//Reset discard
    #####:  498:		state->discardCount[player] = 0;
        -:  499:
        -:  500:		//Shufffle the deck
        -:  501:		//Shuffle the deck up and make it so that we can draw
    #####:  502:		shuffle(player, state);
call    0 never executed
        -:  503:
        -:  504:		if (DEBUG) {
        -:  505:			//Debug statements
        -:  506:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  507:		}
        -:  508:
    #####:  509:		state->discardCount[player] = 0;
        -:  510:
        -:  511:		//Step 2 Draw Card
        -:  512:		//Get current player's hand count
    #####:  513:		count = state->handCount[player];
        -:  514:
        -:  515:		if (DEBUG) {
        -:  516:			//Debug statements
        -:  517:			printf("Current hand count: %d\n", count);
        -:  518:		}
        -:  519:		//Create a holder for the deck count
    #####:  520:		deckCounter = state->deckCount[player];
        -:  521:
    #####:  522:		if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  523:			return -1;
        -:  524:		
        -:  525:		//Add card to hand
    #####:  526:		state->hand[player][count] = state->deck[player][deckCounter - 1];		
    #####:  527:		state->deckCount[player]--;
        -:  528:		//Increment hand count
    #####:  529:		state->handCount[player]++;
        -:  530:	} else {
        -:  531:		//Get current hand count for player
       79:  532:		int count = state->handCount[player];
        -:  533:		int deckCounter;
        -:  534:		if (DEBUG) {
        -:  535:			//Debug statements
        -:  536:			printf("Current hand count: %d\n", count);
        -:  537:		}
        -:  538:		//Create holder for the deck count
       79:  539:		deckCounter = state->deckCount[player];
        -:  540:		//Add card to the hand
       79:  541:		state->hand[player][count] = state->deck[player][deckCounter - 1];
       79:  542:		state->deckCount[player]--;
        -:  543:		//Increment hand count
       79:  544:		state->handCount[player]++;
        -:  545:	}
        -:  546:
       79:  547:	return 0;
        -:  548:}
        -:  549:
function getCost called 58 returned 100% blocks executed 100%
       58:  550:int getCost(int cardNumber) {
       58:  551:	switch (cardNumber) {
branch  0 taken 7%
branch  1 taken 3%
branch  2 taken 3%
branch  3 taken 3%
branch  4 taken 3%
branch  5 taken 3%
branch  6 taken 3%
branch  7 taken 3%
branch  8 taken 3%
branch  9 taken 3%
branch 10 taken 3%
branch 11 taken 3%
branch 12 taken 3%
branch 13 taken 3%
branch 14 taken 3%
branch 15 taken 3%
branch 16 taken 3%
branch 17 taken 3%
branch 18 taken 3%
branch 19 taken 3%
branch 20 taken 3%
branch 21 taken 3%
branch 22 taken 3%
branch 23 taken 3%
branch 24 taken 3%
branch 25 taken 3%
branch 26 taken 3%
branch 27 taken 3%
        -:  552:	case curse:
        4:  553:		return 0;
        -:  554:	case estate:
        2:  555:		return 2;
        -:  556:	case duchy:
        2:  557:		return 5;
        -:  558:	case province:
        2:  559:		return 8;
        -:  560:	case copper:
        2:  561:		return 0;
        -:  562:	case silver:
        2:  563:		return 3;
        -:  564:	case gold:
        2:  565:		return 6;
        -:  566:	case adventurer:
        2:  567:		return 6;
        -:  568:	case council_room:
        2:  569:		return 5;
        -:  570:	case feast:
        2:  571:		return 4;
        -:  572:	case gardens:
        2:  573:		return 4;
        -:  574:	case mine:
        2:  575:		return 5;
        -:  576:	case remodel:
        2:  577:		return 4;
        -:  578:	case smithy:
        2:  579:		return 4;
        -:  580:	case village:
        2:  581:		return 3;
        -:  582:	case baron:
        2:  583:		return 4;
        -:  584:	case great_hall:
        2:  585:		return 3;
        -:  586:	case minion:
        2:  587:		return 5;
        -:  588:	case steward:
        2:  589:		return 3;
        -:  590:	case tribute:
        2:  591:		return 5;
        -:  592:	case ambassador:
        2:  593:		return 3;
        -:  594:	case cutpurse:
        2:  595:		return 4;
        -:  596:	case embargo:
        2:  597:		return 2;
        -:  598:	case outpost:
        2:  599:		return 5;
        -:  600:	case salvager:
        2:  601:		return 4;
        -:  602:	case sea_hag:
        2:  603:		return 4;
        -:  604:	case treasure_map:
        2:  605:		return 4;
        -:  606:	}
        -:  607:
        2:  608:	return -1;
        -:  609:}
        -:  610:
function cardEffect called 8 returned 100% blocks executed 5%
        8:  611:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState* state, int handPos, int* bonus) {
        -:  612:	int i;
        -:  613:	int j;
        -:  614:	int x;
        -:  615:	int index;
        -:  616:	// currentPlayer could also be refactored into individual cards
        8:  617:	int currentPlayer = whoseTurn(state); 
call    0 returned 100%
        -:  618:	
        -:  619:	// moved above the if statement
        -:  620:	int temphand[MAX_HAND];
        -:  621:
        -:  622:	//uses switch to select card and perform actions
        8:  623:	switch (card) {
branch  0 taken 25%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 25%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 25%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 25%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  624:	case adventurer: 
        2:  625:		return playAdventurer(currentPlayer, state);
call    0 returned 100%
        -:  626:
        -:  627:	case council_room:
        -:  628:		//+4 Cards
    #####:  629:		for (i = 0; i < 4; i++) {
branch  0 never executed
branch  1 never executed
    #####:  630:			drawCard(currentPlayer, state);
call    0 never executed
        -:  631:		}
        -:  632:
        -:  633:		//+1 Buy
    #####:  634:		state->numBuys++;
        -:  635:
        -:  636:		//Each other player draws a card
    #####:  637:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####:  638:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####:  639:				drawCard(i, state);
call    0 never executed
        -:  640:			}
        -:  641:		}
        -:  642:
        -:  643:		//put played card in played card pile
    #####:  644:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  645:
    #####:  646:		return 0;
        -:  647:
        -:  648:	case feast:
        -:  649:		//gain card with cost up to 5
        -:  650:		//Backup hand
    #####:  651:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
        -:  652:			//Backup card
    #####:  653:			temphand[i] = state->hand[currentPlayer][i];
        -:  654:			//Set to nothing
    #####:  655:			state->hand[currentPlayer][i] = -1;
        -:  656:		}
        -:  657:
        -:  658:		//Update Coins for Buy
    #####:  659:		updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  660:		x = 1;//Condition to loop on
    #####:  661:		while (x == 1) {
branch  0 never executed
branch  1 never executed
        -:  662:			//Buy one card
    #####:  663:			if (supplyCount(choice1, state) <= 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  664:				if (DEBUG)
        -:  665:					printf("None of that card left, sorry!\n");
        -:  666:
        -:  667:				if (DEBUG)
        -:  668:					printf("Cards Left: %d\n", supplyCount(choice1, state));
    #####:  669:			} else if (state->coins < getCost(choice1)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  670:				printf("That card is too expensive!\n");
call    0 never executed
        -:  671:				if (DEBUG)
        -:  672:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  673:			} else {
        -:  674:				if (DEBUG)
        -:  675:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  676:				//Gain the card
    #####:  677:				gainCard(choice1, state, 0, currentPlayer);
call    0 never executed
        -:  678:				//No more buying cards
    #####:  679:				x = 0;
        -:  680:
        -:  681:				if (DEBUG)
        -:  682:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  683:			}
        -:  684:		}
        -:  685:
        -:  686:		//Reset Hand
    #####:  687:		for (i = 0; i <= state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  688:			state->hand[currentPlayer][i] = temphand[i];
    #####:  689:			temphand[i] = -1;
        -:  690:		}
        -:  691:		//Reset Hand
        -:  692:
    #####:  693:		return 0;
        -:  694:
        -:  695:	case gardens:
    #####:  696:		return -1;
        -:  697:
        -:  698:	case mine:
        -:  699:		//store card we will trash
    #####:  700:		j = state->hand[currentPlayer][choice1]; 
        -:  701:
    #####:  702:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  703:			return -1;
        -:  704:
    #####:  705:		if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  706:			return -1;
        -:  707:
    #####:  708:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  709:			return -1;
        -:  710:
    #####:  711:		gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  712:
        -:  713:		//discard card from hand
    #####:  714:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  715:
        -:  716:		//discard trashed card
    #####:  717:		for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  718:			if (state->hand[currentPlayer][i] == j) {
branch  0 never executed
branch  1 never executed
    #####:  719:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  720:				break;
        -:  721:			}
        -:  722:		}
        -:  723:
    #####:  724:		return 0;
        -:  725:
        -:  726:	case remodel:
        -:  727:		//store card we will trash
    #####:  728:		j = state->hand[currentPlayer][choice1]; 
        -:  729:
    #####:  730:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    #####:  731:			return -1;
        -:  732:
    #####:  733:		gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  734:
        -:  735:		//discard card from hand
    #####:  736:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  737:
        -:  738:		//discard trashed card
    #####:  739:		for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  740:			if (state->hand[currentPlayer][i] == j) {
branch  0 never executed
branch  1 never executed
    #####:  741:				discardCard(i, currentPlayer, state, 0);
call    0 never executed
    #####:  742:				break;
        -:  743:			}
        -:  744:		}
        -:  745:
        -:  746:
    #####:  747:		return 0;
        -:  748:
        -:  749:	case smithy: 
        2:  750:		return playSmithy(currentPlayer, state, handPos);
call    0 returned 100%
        -:  751:		
        -:  752:
        -:  753:	case village:
        -:  754:		//+1 Card
    #####:  755:		drawCard(currentPlayer, state);
call    0 never executed
        -:  756:
        -:  757:		//+2 Actions
    #####:  758:		state->numActions = state->numActions + 2;
        -:  759:
        -:  760:		//discard played card from hand
    #####:  761:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  762:		return 0;
        -:  763:
        -:  764:	case baron:
        -:  765:		// Increase buys by 1!
    #####:  766:		state->numBuys++;
        -:  767:		// Boolean true or going to discard an estate
    #####:  768:		if (choice1 > 0) {
branch  0 never executed
branch  1 never executed
        -:  769:			// Iterator for hand!
    #####:  770:			int p = 0;
        -:  771:			// Flag for discard set!
    #####:  772:			int card_not_discarded = 1;
    #####:  773:			while (card_not_discarded) {
branch  0 never executed
branch  1 never executed
    #####:  774:				if (state->hand[currentPlayer][p] == estate) {
branch  0 never executed
branch  1 never executed
        -:  775:					//Found an estate card!
        -:  776:					//Add 4 coins to the amount of coins
    #####:  777:					state->coins += 4;
    #####:  778:					state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  779:					state->discardCount[currentPlayer]++;
    #####:  780:					for (; p < state->handCount[currentPlayer]; p++) {
branch  0 never executed
branch  1 never executed
    #####:  781:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  782:					}
    #####:  783:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  784:					state->handCount[currentPlayer]--;
        -:  785:					//Exit the loop
    #####:  786:					card_not_discarded = 0;
    #####:  787:				} else if (p > state->handCount[currentPlayer]) {
branch  0 never executed
branch  1 never executed
        -:  788:					if (DEBUG) {
        -:  789:						printf("No estate cards in your hand, invalid choice\n");
        -:  790:						printf("Must gain an estate if there are any\n");
        -:  791:					}
    #####:  792:					if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  793:						gainCard(estate, state, 0, currentPlayer);
call    0 never executed
        -:  794:						//Decrement estates
    #####:  795:						state->supplyCount[estate]--;
    #####:  796:						if (supplyCount(estate, state) == 0) 
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  797:							isGameOver(state);
call    0 never executed
        -:  798:					}
        -:  799:					//Exit the loop
    #####:  800:					card_not_discarded = 0;
        -:  801:				} else {
        -:  802:					//Next card
    #####:  803:					p++;
        -:  804:				}
        -:  805:			}
        -:  806:		} else {
    #####:  807:			if (supplyCount(estate, state) > 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  808:				//Gain an estate
    #####:  809:				gainCard(estate, state, 0, currentPlayer);
call    0 never executed
        -:  810:				//Decrement Estates
    #####:  811:				state->supplyCount[estate]--;
    #####:  812:				if (supplyCount(estate, state) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  813:					isGameOver(state);
call    0 never executed
        -:  814:			}
        -:  815:		}
        -:  816:
        -:  817:
    #####:  818:		return 0;
        -:  819:
        -:  820:	case great_hall:
        -:  821:		//+1 Card
        2:  822:		drawCard(currentPlayer, state);
call    0 returned 100%
        -:  823:
        -:  824:		//+1 Actions
        2:  825:		state->numActions++;
        -:  826:
        -:  827:		//discard card from hand
        2:  828:		discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        2:  829:		return 0;
        -:  830:
        -:  831:	case minion:
        -:  832:		//+1 action
    #####:  833:		state->numActions++;
        -:  834:
        -:  835:		//discard card from hand
    #####:  836:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  837:
    #####:  838:		if (choice1) {
branch  0 never executed
branch  1 never executed
        -:  839:			//+2 coins
    #####:  840:			state->coins = state->coins + 2;
    #####:  841:		} else if (choice2) {
branch  0 never executed
branch  1 never executed
        -:  842:			//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  843:			
        -:  844:			//discard hand
    #####:  845:			while (numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  846:				discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  847:			
        -:  848:
        -:  849:			//draw 4
    #####:  850:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
    #####:  851:				drawCard(currentPlayer, state);
call    0 never executed
        -:  852:
        -:  853:			//other players discard hand and redraw if hand size > 4
    #####:  854:			for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####:  855:				if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####:  856:					if (state->handCount[i] > 4) {
branch  0 never executed
branch  1 never executed
        -:  857:						//discard hand
    #####:  858:						while (state->handCount[i] > 0)
branch  0 never executed
branch  1 never executed
    #####:  859:							discardCard(handPos, i, state, 0);
call    0 never executed
        -:  860:
        -:  861:						//draw 4
    #####:  862:						for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
    #####:  863:							drawCard(i, state);
call    0 never executed
        -:  864:					}
        -:  865:				}
        -:  866:			}
        -:  867:		}
    #####:  868:		return 0;
        -:  869:
        -:  870:	case steward:
    #####:  871:		if (choice1 == 1) {
branch  0 never executed
branch  1 never executed
        -:  872:			//+2 cards
    #####:  873:			drawCard(currentPlayer, state);
call    0 never executed
    #####:  874:			drawCard(currentPlayer, state);
call    0 never executed
    #####:  875:		} else if (choice1 == 2) {
branch  0 never executed
branch  1 never executed
        -:  876:			//+2 coins
    #####:  877:			state->coins = state->coins + 2;
        -:  878:		} else {
        -:  879:			//trash 2 cards in hand
    #####:  880:			discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####:  881:			discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -:  882:		}
        -:  883:
        -:  884:		//discard card from hand
    #####:  885:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  886:		return 0;
        -:  887:
        -:  888:	case tribute: 
    #####:  889:		return playTribute(currentPlayer, state);
call    0 never executed
        -:  890:
        -:  891:	case ambassador:
        -:  892:		//used to check if player has enough cards to discard
    #####:  893:		j = 0; 
        -:  894:
    #####:  895:		if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  896:			return -1;
        -:  897:
    #####:  898:		if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
    #####:  899:			return -1;
        -:  900:
    #####:  901:		for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  902:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  903:				j++;
        -:  904:		}
    #####:  905:		if (j < choice2)
branch  0 never executed
branch  1 never executed
    #####:  906:			return -1;
        -:  907:
        -:  908:		if (DEBUG)
        -:  909:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -:  910:
        -:  911:		//increase supply count for choosen card by amount being discarded
    #####:  912:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -:  913:
        -:  914:		//each other player gains a copy of revealed card
    #####:  915:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####:  916:			if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
    #####:  917:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -:  918:		}
        -:  919:
        -:  920:		//discard played card from hand
    #####:  921:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  922:
        -:  923:		//trash copies of cards returned to supply
    #####:  924:		for (j = 0; j < choice2; j++) {
branch  0 never executed
branch  1 never executed
    #####:  925:			for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  926:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1]) {
branch  0 never executed
branch  1 never executed
    #####:  927:					discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####:  928:					break;
        -:  929:				}
        -:  930:			}
        -:  931:		}
        -:  932:
    #####:  933:		return 0;
        -:  934:
        -:  935:	case cutpurse: 
    #####:  936:		return playCutpurse(currentPlayer, state, handPos);
call    0 never executed
        -:  937:
        -:  938:	case embargo: 
        2:  939:		return playEmbargo(currentPlayer, state, handPos, choice1);
call    0 returned 100%
        -:  940:
        -:  941:	case outpost:
        -:  942:		//set outpost flag
    #####:  943:		state->outpostPlayed++;
        -:  944:
        -:  945:		//discard card
    #####:  946:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  947:		return 0;
        -:  948:
        -:  949:	case salvager:
        -:  950:		//+1 buy
    #####:  951:		state->numBuys++;
        -:  952:
    #####:  953:		if (choice1) {
branch  0 never executed
branch  1 never executed
        -:  954:			//gain coins equal to trashed card
    #####:  955:			state->coins = state->coins + getCost(handCard(choice1, state));
call    0 never executed
call    1 never executed
        -:  956:			//trash card
    #####:  957:			discardCard(choice1, currentPlayer, state, 1);
call    0 never executed
        -:  958:		}
        -:  959:
        -:  960:		//discard card
    #####:  961:		discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  962:		return 0;
        -:  963:
        -:  964:	case sea_hag:
    #####:  965:		for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####:  966:			if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####:  967:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];
    #####:  968:				state->deckCount[i]--;
    #####:  969:				state->discardCount[i]++;
        -:  970:				//Top card now a curse
    #####:  971:				state->deck[i][state->deckCount[i]--] = curse;
        -:  972:			}
        -:  973:		}
    #####:  974:		return 0;
        -:  975:
        -:  976:	case treasure_map:
        -:  977:		//search hand for another treasure_map
    #####:  978:		index = -1;
    #####:  979:		for (i = 0; i < state->handCount[currentPlayer]; i++) {
branch  0 never executed
branch  1 never executed
    #####:  980:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  981:				index = i;
    #####:  982:				break;
        -:  983:			}
        -:  984:		}
    #####:  985:		if (index > -1) {
branch  0 never executed
branch  1 never executed
        -:  986:			//trash both treasure cards
    #####:  987:			discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####:  988:			discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -:  989:
        -:  990:			//gain 4 Gold cards
    #####:  991:			for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
    #####:  992:				gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -:  993:
        -:  994:			//return success
    #####:  995:			return 1;
        -:  996:		}
        -:  997:
        -:  998:		//no second treasure_map found in hand
    #####:  999:		return -1;
        -: 1000:	}
        -: 1001:
    #####: 1002:	return -1;
        -: 1003:}
        -: 1004:
function discardCard called 6 returned 100% blocks executed 78%
        6: 1005:int discardCard(int handPos, int currentPlayer, struct gameState* state, int trashFlag)
        -: 1006:{
        -: 1007:	//if card is not trashed, added to Played pile 
        6: 1008:	if (trashFlag < 1)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -: 1009:	{
        -: 1010:		//add card to played pile
        4: 1011:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
        4: 1012:		state->playedCardCount++;
        -: 1013:	}
        -: 1014:
        -: 1015:	//set played card to -1
        6: 1016:	state->hand[currentPlayer][handPos] = -1;
        -: 1017:
        -: 1018:	//remove card faserom player's hand
        6: 1019:	if (handPos == (state->handCount[currentPlayer] - 1)) //last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1020:	{
        -: 1021:		//reduce number of cards in hand
    #####: 1022:		state->handCount[currentPlayer]--;
        -: 1023:	}
        6: 1024:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1025:	{
        -: 1026:		//reduce number of cards in hand
    #####: 1027:		state->handCount[currentPlayer]--;
        -: 1028:	}
        -: 1029:	else
        -: 1030:	{
        -: 1031:		//replace discarded card with last card in hand
        6: 1032:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1033:		//set last card to -1
        6: 1034:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1035:		//reduce number of cards in hand
        6: 1036:		state->handCount[currentPlayer]--;
        -: 1037:	}
        -: 1038:
        6: 1039:	return 0;
        -: 1040:}
        -: 1041:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1042:int gainCard(int supplyPos, struct gameState* state, int toFlag, int player)
        -: 1043:{
        -: 1044:	//Note: supplyPos is enum of choosen card
        -: 1045:
        -: 1046:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1047:	if (supplyCount(supplyPos, state) < 1)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1048:	{
    #####: 1049:		return -1;
        -: 1050:	}
        -: 1051:
        -: 1052:	//added card for [whoseTurn] current player:
        -: 1053:	// toFlag = 0 : add to discard
        -: 1054:	// toFlag = 1 : add to deck
        -: 1055:	// toFlag = 2 : add to hand
        -: 1056:
    #####: 1057:	if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1058:	{
    #####: 1059:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1060:		state->deckCount[player]++;
        -: 1061:	}
    #####: 1062:	else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1063:	{
    #####: 1064:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1065:		state->handCount[player]++;
        -: 1066:	}
        -: 1067:	else
        -: 1068:	{
    #####: 1069:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1070:		state->discardCount[player]++;
        -: 1071:	}
        -: 1072:
        -: 1073:	//decrease number in supply pile
    #####: 1074:	state->supplyCount[supplyPos]--;
        -: 1075:
    #####: 1076:	return 0;
        -: 1077:}
        -: 1078:
function updateCoins called 13 returned 100% blocks executed 82%
       13: 1079:int updateCoins(int player, struct gameState* state, int bonus)
        -: 1080:{
        -: 1081:	int i;
        -: 1082:
        -: 1083:	//reset coin count
       13: 1084:	state->coins = 0;
        -: 1085:
        -: 1086:	//add coins for each Treasure card in player's hand
       78: 1087:	for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1088:	{
       65: 1089:		if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1090:		{
       52: 1091:			state->coins += 1;
        -: 1092:		}
       13: 1093:		else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1094:		{
    #####: 1095:			state->coins += 2;
        -: 1096:		}
       13: 1097:		else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1098:		{
    #####: 1099:			state->coins += 3;
        -: 1100:		}
        -: 1101:	}
        -: 1102:
        -: 1103:	//add bonus
       13: 1104:	state->coins += bonus;
        -: 1105:
       13: 1106:	return 0;
        -: 1107:}
        -: 1108:
function playSmithy called 2 returned 100% blocks executed 100%
        2: 1109:int playSmithy(int currentPlayer, struct gameState* state, int handPos) {
        -: 1110:	//+3 Cards
        -: 1111:	int i;
        -: 1112:	// introduce bug, 4 instead of 3 cards
       10: 1113:	for (i = 0; i < 4; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        8: 1114:		drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1115:	}
        -: 1116:	
        -: 1117:	//discard card from hand
        2: 1118:	discardCard(handPos, currentPlayer, state, 0);
call    0 returned 100%
        2: 1119:	return 0;
        -: 1120:}
        -: 1121:
function playCutpurse called 0 returned 0% blocks executed 0%
    #####: 1122:int playCutpurse(int currentPlayer, struct gameState* state, int handPos) {
        -: 1123:	int i, j, k;
    #####: 1124:	updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1125:	for (i = 0; i < state->numPlayers; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1126:		if (i != currentPlayer) {
branch  0 never executed
branch  1 never executed
    #####: 1127:			for (j = 0; j < state->handCount[i]; j++) {
branch  0 never executed
branch  1 never executed
    #####: 1128:				if (state->hand[i][j] == copper) {
branch  0 never executed
branch  1 never executed
        -: 1129:					// introduce bug, does not make other players discard coppers O.o
        -: 1130:					//discardCard(j, i, state, 0);
    #####: 1131:					break;
        -: 1132:				}
    #####: 1133:				if (j == state->handCount[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1134:					for (k = 0; k < state->handCount[i]; k++) {
branch  0 never executed
branch  1 never executed
        -: 1135:						if (DEBUG)
        -: 1136:							printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1137:					}
    #####: 1138:					break;
        -: 1139:				}
        -: 1140:			}
        -: 1141:		}
        -: 1142:	}
        -: 1143:
        -: 1144:	//discard played card from hand
    #####: 1145:	discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1146:
    #####: 1147:	return 0;
        -: 1148:}
        -: 1149:
function playAdventurer called 2 returned 100% blocks executed 67%
        2: 1150:int playAdventurer(int currentPlayer, struct gameState* state) {
        -: 1151:	int temphand[MAX_HAND];
        2: 1152:	int drawntreasure = 0;
        2: 1153:	int cardDrawn = -1;
        -: 1154:	// this is the counter for the temp hand
        2: 1155:	int z = 0;	
        -: 1156:
        8: 1157:	while (drawntreasure < 2) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        4: 1158:		if (state->deckCount[currentPlayer] < 1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1159:			// if the deck is empty we need to shuffle discard and add to deck
    #####: 1160:			shuffle(currentPlayer, state);
call    0 never executed
        -: 1161:		}
        4: 1162:		drawCard(currentPlayer, state);
call    0 returned 100%
        -: 1163:		// top card of hand is most recently drawn card.
        4: 1164:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];
        4: 1165:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        4: 1166:			drawntreasure++;
        -: 1167:		else {
    #####: 1168:			temphand[z] = cardDrawn;
        -: 1169:			// this should just remove the top card (the most recently drawn one).
    #####: 1170:			state->handCount[currentPlayer]--; 
        -: 1171:			// introduce bug, removes an extra card
    #####: 1172:			state->handCount[currentPlayer]--;
    #####: 1173:			z++;
        -: 1174:		}
        -: 1175:	}
        -: 1176:	
        4: 1177:	while (z - 1 >= 0) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -: 1178:		// discard all cards in play that have been drawn
    #####: 1179:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; 
    #####: 1180:		z = z - 1;
        -: 1181:	}
        -: 1182:	
        2: 1183:	return 0;
        -: 1184:}
        -: 1185:
function playEmbargo called 2 returned 100% blocks executed 80%
        2: 1186:int playEmbargo(int currentPlayer, struct gameState* state, int handPos, int choice1) {
        -: 1187:	//+2 Coins
        2: 1188:	state->coins = state->coins + 2;
        -: 1189:
        -: 1190:	//see if selected pile is in play
        2: 1191:	if (state->supplyCount[choice1] == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1192:		return -1;
        -: 1193:	}
        -: 1194:
        -: 1195:	//add embargo token to selected supply pile
        2: 1196:	state->embargoTokens[choice1]++;
        -: 1197:
        -: 1198:	//trash card
        2: 1199:	discardCard(handPos, currentPlayer, state, 1);
call    0 returned 100%
        2: 1200:	return 0;
        -: 1201:
        -: 1202:}
        -: 1203:
function playTribute called 0 returned 0% blocks executed 0%
    #####: 1204:int playTribute(int currentPlayer, struct gameState* state) {
        -: 1205:	
        -: 1206:	int i;
    #####: 1207:	int nextPlayer = currentPlayer + 1;
    #####: 1208:	int tributeRevealedCards[2] = {-1, -1};
    #####: 1209:	if (nextPlayer > (state->numPlayers - 1))
branch  0 never executed
branch  1 never executed
    #####: 1210:		nextPlayer = 0;
        -: 1211:	
    #####: 1212:	if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
branch  0 never executed
branch  1 never executed
    #####: 1213:		if (state->deckCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1214:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1215:			state->deckCount[nextPlayer]--;
    #####: 1216:		} else if (state->discardCount[nextPlayer] > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1217:			tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1218:			state->discardCount[nextPlayer]--;
        -: 1219:		} else {
        -: 1220:			//No Card to Reveal
        -: 1221:			if (DEBUG) 
        -: 1222:				printf("No cards to reveal\n");
        -: 1223:		}
        -: 1224:	} else {
    #####: 1225:		if (state->deckCount[nextPlayer] == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1226:			for (i = 0; i < state->discardCount[nextPlayer]; i++) {
branch  0 never executed
branch  1 never executed
        -: 1227:				//Move to deck
    #####: 1228:				state->deck[nextPlayer][i] = state->discard[nextPlayer][i];
    #####: 1229:				state->deckCount[nextPlayer]++;
    #####: 1230:				state->discard[nextPlayer][i] = -1;
    #####: 1231:				state->discardCount[nextPlayer]--;
        -: 1232:			}
        -: 1233:			//Shuffle the deck
        -: 1234:			// introduce bug, doesn't shuffle the deck
        -: 1235:			//shuffle(nextPlayer, state);
        -: 1236:		}
    #####: 1237:		tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1238:		state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1239:		state->deckCount[nextPlayer]--;
    #####: 1240:		tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1241:		state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1242:		state->deckCount[nextPlayer]--;
        -: 1243:	}
        -: 1244:
    #####: 1245:	if (tributeRevealedCards[0] == tributeRevealedCards[1]) {
branch  0 never executed
branch  1 never executed
        -: 1246:		//If we have a duplicate card, just drop one 
    #####: 1247:		state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1248:		state->playedCardCount++;
    #####: 1249:		tributeRevealedCards[1] = -1;
        -: 1250:	}
        -: 1251:
    #####: 1252:	for (i = 0; i <= 2; i ++) {
branch  0 never executed
branch  1 never executed
    #####: 1253:		if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1254:			|| tributeRevealedCards[i] == gold) {
branch  0 never executed
branch  1 never executed
        -: 1255:			//Treasure cards
    #####: 1256:			state->coins += 2;
    #####: 1257:		} else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1258:			|| tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1259:			|| tributeRevealedCards[i] == great_hall) {
branch  0 never executed
branch  1 never executed
        -: 1260:			//Victory Card Found
    #####: 1261:			drawCard(currentPlayer, state);
call    0 never executed
    #####: 1262:			drawCard(currentPlayer, state);
call    0 never executed
        -: 1263:		} else {
        -: 1264:			//Action Card
    #####: 1265:			state->numActions = state->numActions + 2;
        -: 1266:		}
        -: 1267:	}
        -: 1268:
    #####: 1269:	return 0;
        -: 1270:}
        -: 1271://end of dominion.c
        -: 1272:
